# Архитектура проекта

Проект написан с использованием варианта методологии [Feature-Sliced Design](https://feature-sliced.design/).
Реализация FSD в проекте отличается от базовой FSD тем, что под _features_ здесь
подразумевается не _use-cases_, как в _Clean Architecture_, а полноценные самостоятельные единицы 
функционала приложения.

## Отличия в работе со слоями:

### Features
Например - если в базовом FSD аутентификация представляет собой несколько фич (sign-in, sign-out),
то здесь это **объединено в одну фичу auth.**

Аналогично, заполнение формы пользователем от начала и до конца также является одной фичей, а не совмещением
нескольких фич.

### Entities
Слой _entities_ содержит в себе информацию о сущностях в проекте, оформленных **на языке бизнеса.**
Однако, его роль ограничивается объявлением типов сущностей, репозиториев (обёрток над api-запросами) для работы 
с сущностью и хранением статического ui.

Обратите внимание, что в entities, как и в других слоях кроме shared запрещены кросс-импорты. Это значит, что если
мы имеем такую сущность, которая связана с другими сущностями - необходимо между ними оформить слабую связанность 
(например, через generic-типы).

Аналогично - если несколько сущностей являются наследниками какого-либо базового типа.

### Pages и Widgets
Слои _pages_ и _widgets_ здесь служат исключительно для композиции фич и должны содержать как можно меньше бизнес-логики
или не содержать её вовсе, т.к. их главной ролью должно быть отображение совмещённых фич, а не логика их работы.

Соответственно, слой _pages_ композирует фичи для каждой страницы, а слой _widgets_ содержит в себе композицию
фич, которая может быть переиспользована между страницами.

## Оформление слайсов
Ввиду сложности логики проекта и особенностей, описанных выше - каждый слайс может содержать в себе несколько более
мелких под-слайсов. Здесь можно выделить два сценария:

1. Слайс принадлежит сложной сущности, у которой есть сущности-потомки. В таком случае слайс будет содержать
сегменты ui/model/lib и т.д. для основной сущности и отдельные папки под свои дочерние сущности. Каждая дочерняя
сущность будет иметь уже свой ui/model/lib, а если и у неё есть потомок - аналогично размещаем его в папке родителя.
Т.е. файловая структура сущностей должна быть древовидной, отражая взаимосвязи между этими сущностями. Стоит отметить,
что излишняя связанность сущностей может навредить архитектуре проекта, поэтому её по возможности стоит избегать.
Если сущности не связаны напрямую на уровне типов или связаны слабо - их лучше сделать независимыми друг от друга.

2. Несколько сущностей являются наследниками какого-либо базового типа. В таком случае они также помещаются в
один слайс, а их общая логика помещается во внутреннюю папку base.
Пример - если у нас есть несколько сущностей пользователя, которые наследуются от базового типа IUser, то
мы создаём единый слайс `entities/user`. Общая логика всех этих типов пользователей будет храниться 
в `entities/user/base`, тогда как конкретные сущности пользователя будут храниться, например, 
в `entities/user/admin` и `entities/user/guest`.
